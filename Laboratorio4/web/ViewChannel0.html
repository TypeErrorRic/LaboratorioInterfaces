<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Analog Channel Live Chart</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
  <style>
    body { background: #0d1117; color: #e6edf3; }
    .card { background: #161b22; border-color: #30363d; }
    .badge-status { min-width: 110px; }
  </style>
</head>
<body>
  <div class="container py-4">
    <div class="d-flex align-items-center mb-4">
      <div>
        <h1 id="pageTitle" class="h3 mb-1">Analog Channel</h1>
        <p class="mb-0 text-secondary">Data vs. time from int_proceso_vars_data</p>
      </div>
      <div class="ms-auto d-flex gap-2">
        <span id="connStatus" class="badge bg-danger badge-status">Disconnected</span>
        <span id="lastUpdate" class="badge bg-secondary">Last update: --</span>
      </div>
    </div>

    <div class="card shadow-sm">
      <div class="card-body">
        <div class="d-flex justify-content-between align-items-center mb-3">
          <div>
            <span class="badge bg-primary me-2">Var ID: <span id="varIdLabel">--</span></span>
            <span class="badge bg-info text-dark">Channel: <span id="channelLabel">ADC?</span></span>
          </div>
          <div class="text-end">
            <div class="text-secondary small">Latest value</div>
            <div id="latestValue" class="h4 mb-0">--</div>
          </div>
        </div>
        <canvas id="chart" height="120"></canvas>
      </div>
    </div>
  </div>

  <script>
    // Config
    const qs = new URLSearchParams(location.search);
    const WS_PORT = parseInt(qs.get('wsPort')) || (parseInt(location.port) || 8080);
    const channel = 0; // Este archivo siempre muestra ADC0
    const WS_URL = `ws://${location.hostname}:${WS_PORT}`;
    const ANALOG_BASE_ID = 10;
    const VAR_ID = ANALOG_BASE_ID + channel;
    const MAX_POINTS = 300;
    const WINDOW_MS = 10000; // Mostrar solo los últimos 10 segundos

    // Elements
    const connStatusEl = document.getElementById('connStatus');
    const lastUpdateEl = document.getElementById('lastUpdate');
    const latestValueEl = document.getElementById('latestValue');
    const varIdLabel = document.getElementById('varIdLabel');
    const channelLabel = document.getElementById('channelLabel');
    const pageTitle = document.getElementById('pageTitle');
    varIdLabel.textContent = VAR_ID;
    channelLabel.textContent = `ADC${channel}`;
    pageTitle.textContent = `Analog Channel ADC${channel}`;

    let ws;
    let chart;

    function setStatus(connected) {
      connStatusEl.textContent = connected ? 'Connected' : 'Disconnected';
      connStatusEl.className = `badge badge-status ${connected ? 'bg-success' : 'bg-danger'}`;
    }

    function formatTime(ts = Date.now()) {
      return new Date(ts).toLocaleTimeString();
    }

    function initChart() {
      const ctx = document.getElementById('chart').getContext('2d');
      chart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [{
            label: `ADC${channel}`,
            data: [],
            borderColor: '#4cc9f0',
            backgroundColor: 'rgba(76, 201, 240, 0.1)',
            tension: 0.2,
            pointRadius: 0
          }]
        },
        options: {
          responsive: true,
          animation: false,
          scales: {
            x: {
              type: 'linear',
              title: { display: true, text: 'Tiempo (ms)' },
              ticks: { color: '#9ba3af' },
              grid: { color: '#21262d' }
            },
            y: {
              title: { display: true, text: 'Valor' },
              ticks: { color: '#9ba3af' },
              grid: { color: '#21262d' },
              min: 0,
              max: 5
            }
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: ctx => ` Valor: ${ctx.parsed.y} (t=${ctx.parsed.x} ms)`
              }
            }
          }
        }
      });
    }

    function handleVarsData(rows) {
      const dataset = chart.data.datasets[0].data;
      const filtered = rows.filter(r => r.int_proceso_vars_id === VAR_ID);
      if (filtered.length === 0) return;

      filtered.forEach(row => {
        dataset.push({ x: Number(row.tiempo), y: Number(row.valor) });
      });

      dataset.sort((a, b) => a.x - b.x);

      // Mantener una ventana móvil de 10 segundos
      const latestX = dataset.length ? dataset[dataset.length - 1].x : null;
      if (latestX !== null) {
        const minWindow = latestX - WINDOW_MS;
        while (dataset.length && dataset[0].x < minWindow) {
          dataset.shift();
        }
        chart.options.scales.x.min = Math.max(0, minWindow);
        chart.options.scales.x.max = latestX;
      }

      if (dataset.length > MAX_POINTS) {
        dataset.splice(0, dataset.length - MAX_POINTS);
      }

      const latest = filtered[filtered.length - 1];
      latestValueEl.textContent = latest.valor;
      lastUpdateEl.textContent = `Last update: ${formatTime()}`;
      chart.update('none');
    }

    function connect() {
      ws = new WebSocket(WS_URL);

      ws.onopen = () => setStatus(true);
      ws.onclose = () => {
        setStatus(false);
        setTimeout(connect, 2000);
      };
      ws.onerror = () => setStatus(false);
      ws.onmessage = evt => {
        try {
          const payload = JSON.parse(evt.data);
          if (payload.type === 'vars_data' && Array.isArray(payload.data)) {
            handleVarsData(payload.data);
          }
        } catch (err) {
          console.error('Failed to parse message', err);
        }
      };
    }

    initChart();
    connect();
  </script>
</body>
</html>
